<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Klein Bottle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="style.css" rel="stylesheet" type="text/css">
<script src="jquery-1.6.4.js"></script>
<script src="underscore.js"></script>

<script src="util.js"></script>
<script src="ui.js"></script>
<script src="math.js"></script>
<script src="shapes.js"></script>
<script src="n22d.js"></script>

<style type="text/css">
    html, body {
        height: 100%;
    }
</style>

<script type="text/javascript">
    var n22d, model, ui, linkable; // global for debugging

    $(document).ready(function() {
        var x_rot = new Rotation(1, 3, Math.PI/2);
        var ui_rot = new StaticTransform();
        var position = new Position(new Vector([0, 0, 0, -8]));
        model = new Model(klein_bottle(20, 60));
        model.transforms.a = [position, ui_rot, x_rot];
        n22d = new N22d($('#n22d'), [model]);
        n22d.animate();
        n22d.ondrag(function(dragger) {
            if (!dragger.changed())
                return;
            var pos = model.transforms.transform.times(new Vector([1]));
            pos = new Vector(pos.a.slice(0, 4)); // XXX
            // mouse ray
            var ray_prev = n22d.screen2world(dragger.x_prev, dragger.y_prev);
            var ray = n22d.screen2world(dragger.x, dragger.y);
            // handle on a sphere
            var handle_prev = ray_sphere_intersect(ray_prev, pos, 3).point_minus(pos);
            var handle = ray_sphere_intersect(ray, pos, 3).point_minus(pos);
            ui_rot.transform = new InfiniteMatrix(rotate_to(handle_prev, handle)).times(ui_rot.transform);
        });
        n22d.ondrag(function(dragger) {
            if (!dragger.changed())
                return;
            var pos = model.transforms.transform.times(new Vector([1]));
            pos = new Vector(pos.a.slice(0, 4)); // XXX
            // mouse ray
            var ray_prev = n22d.screen2world(dragger.x_prev, dragger.y_prev);
            var ray = n22d.screen2world(dragger.x, dragger.y);
            // handle on a sphere
            var handle_prev = ray_sphere_intersect(ray_prev, pos, 3).point_minus(pos);
            var handle = ray_sphere_intersect(ray, pos, 3).point_minus(pos);
            var swap = new InfiniteMatrix().to_swap(3, 4);
            ui_rot.transform = swap.times(new InfiniteMatrix(rotate_to(handle_prev, handle))).times(swap).times(ui_rot.transform);
        }, true);
    });

    function rotate_to(src, dst) {
        src = src.normalized();
        dst = dst.normalized();
        var axis = cross_product(src, dst);
        var sin = axis.norm();
        var cos = src.dot(dst);
        var rot = new Matrix(4, 4).to_I();
        rot.a[1][1] = rot.a[2][2] = cos;
        rot.a[1][2] = -sin;
        rot.a[2][1] = sin;

        var space = new Space();
        space.expand([new Vector([1]), src, dst, axis]);
        var basis_change = space.basis_change();
        return basis_change.transpose().times(rot).times(basis_change);
    }

    function rotate_to_test(src, dst) {
        return [rotate_to(src, dst).times(src), dst];
    }

    function cross_product(a, b) {
        return new Vector([
            0,
            a.a[2]*b.a[3] - a.a[3]*b.a[2],
            a.a[3]*b.a[1] - a.a[1]*b.a[3],
            a.a[1]*b.a[2] - a.a[2]*b.a[1]
        ]);
    }

    // ray from origin
    // returns closest point of intersection to the origin
    function ray_sphere_intersect(ray_velocity, sphere_center, sphere_radius) {
        // substitute parametric line into sphere relation
        var v = ray_velocity;
        var c = sphere_center;
        var r = sphere_radius;
        var x2 = v.a[1]*v.a[1] + v.a[2]*v.a[2] + v.a[3]*v.a[3];
        var x1 = -2*v.a[1]*c.a[1] - 2*v.a[2]*c.a[2] - 2*v.a[3]*c.a[3];
        var x0 = c.a[1]*c.a[1] + c.a[2]*c.a[2] + c.a[3]*c.a[3] - r*r;
        var s = solve_quadratic(x2, x1, x0);
        v.a[0] = 0; // XXX terrible
        v = _.min([v.times(s[0]), v.times(s[1])], function(r) { return r.norm(); });
        v.a[0] = 1; // XXX terrible
        return v;
    }

    function solve_quadratic(a, b, c) {
        var desc = Math.sqrt(b*b - 4*a*c);
        if (isNaN(desc))
            throw new Error('no solutions');
        else if (desc == 0)
            return [-b/a/2];
        else
            return [(desc - b)/a/2, (-desc - b)/a/2];
    }
</script>
</head>

<body>
    <div id='n22d' style='min-height: 100%;'></div>
</body>

</html>
